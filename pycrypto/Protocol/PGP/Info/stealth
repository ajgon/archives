From andrewk@cst.ca Tue Feb 27 09:49 EST 1996
Received: from lapis.cst.ca by emerald.cst.ca with SMTP
	(1.38.193.4/15.6) id AA09225; Tue, 27 Feb 1996 09:49:32 -0500
Return-Path: <andrewk@cst.ca>
Received: by lapis.cst.ca
	(1.38.193.5/15.6) id AA00422; Tue, 27 Feb 1996 10:00:37 -0500
From: Andrew Kuchling <andrewk@cst.ca>
Subject: Re: Stealth PGP work (fwd)
To: develop@emerald.cst.ca
Date: Tue, 27 Feb 96 10:00:37 EST
Mailer: Elm [revision: 70.85.2.1]



(migrating to coderpunks)

Bill Stewart <stewarts@ix.netcom.com> writes on cpunks:
> Derek wrote:
> > I'm not familiar with the exact details of what stealth does, which is
> > why I asked for more details.  The problem is that PGP API, when
> > decrypting a message, keys off the PGP packet types in order to
> > operate.  If stealth can work outside of PGP 2.6.2, then it should be
> > possible to add it on to PGP 3, theoretically.
> 
> My assumption was that the request for "stealth" was for the more general
> feature of stealthiness rather than the specific implementation provided
> by the Stealth program that "Harry Hastur" wrote to solve it.
> I suspect that the new toolkits in PGP3 will make it much easier to
> implement a good stealth program, but it may or may not be perfect.
> 
> The basic requirement is that you can't tell whether a message is
> PGP or Random Bits unless it's for you, for applications like steganography;

that's Henry's stealth approach,

> a milder requirement is that you at least can't tell who it's for and
> also can't verify your guess about the recipient if you guess right.

This could be useful for mail drops to alt.anonymous.messages, it
would save the necessity of generating a new key, when you don't mind
the sender knowing the recipients normal key, but don't want anyone
else to know.  Yet you don't care that anyone knows it is a PGP message.

> Sure, most people don't need it, but most people don't need 1024-bit crypto
> either;

I think PGP should cater for less rosy situations than that in the US
at present: there are other countries where clandestine use may be
necessary because of local laws, and the way the NSA is headed you
can't be too sure of the US future either.  (How's the idea future
odds for mandatory key escrow in the near future?)

I'd vote for both of your suggested modes, I think they would be
useful to have.

> 512 bits will protect just about everybody from just about every real threat
> for the next decade or so.  One requirement is getting rid of identifiable
> packet type and length indicators, 

separately from the requirement to strip off the keyid?  People can
see it's from you, but they can't tell what length and what packets
are in there?

> another is getting rid of the key id,

yep.

> and another is the more subtle problem that M**e mod n isn't
> distributed evenly.

yep.  m**e % n not being evenly distrubited would mean that you should
do the normalising transformation on the RSA block even if you are
just stripping the keyid and leaving the packet types and lengths; not
only does it give away that it is a PGP message (which is now obvious
due to packet type fields), but with enough messages it gives away n,
and hence the keyid.

> Stealthing the block type and length indicators isn't a requirement for
> ascii-armored and clearsigned versions (obviously not for clearsigned,
> and if you don't like your ascii version starting with ----- BEGIN PGP,
> you can encode the stealth binary with uuencode or MIME instead.)

You'd need to strip the length indicators if you wanted the option to
pad the message with random junk to a fixed size (eg much like
mixmaster fixed sized packets).

> [...]
> 
> I also don't remember if the block with the public-key-encrypted session key
> has a length indicator or not; 

it does:

: RSA public-key-encrypted packet
: -------------------------------
: 
: Offset  Length  Meaning
: 0       1       CTB for RSA public-key-encrypted packet
: 1       2       16-bit (or maybe 8-bit) length of packet

> if it doesn't, parts of the job become easier.

> For all the following blocks, you can xor the packet type and length indictor
> with shared-secret random bits.  An obvious source, assuming the API lets
> you have it,
> is the random padding that PGP adds to the session key when PK-encrypting,
> or some PRNG output derived from that, and you can do the xoring quickly
> without having to open up packets beyond that.  

This is an interesting approach to allowing a stealthy operation which
can deal with multiple blocks, Henry's method will only recover one
IDEA block.

Another method would be to rely on all outer packets after the RSA
packet(s) being IDEA encrypted (is this the case?) to reconstruct the
multiple packet lengths.  Literal plaintext blocks have length fields
also, so the length information in the outer IDEA block which was
stripped in a stealth operation was redundant anyway.  So you could
modify the IDEA decrypt code to use the length field encoded within it
if there is no external length field.  

(saves arguments about whether revealing some of the padding
theoretically weakens anything, but may not fit cleanly in to Derek
and Colins software architecture.)

(It is possible with Henry's existing code to pad data with random
junk because of the redundant internal length fields: pgp does IDEA
decrypt the packet (including a meaningless decrypt of trailing junk),
but the internal packet length means that it then goes on to ignore
the decrypted padding junk).

> The initial block's types can be played with by an external program;
> it wouldn't leak too much data to always use a value other than the
> value a normal binary-flavor PGP program would use, so Stealth can
> just pass non-stealthed files through to PGP instead of
> destealthing.

Stealth autodetect, so you could just point PGP at any message,
steatlhed or not, and have it try to make sense of it?  Because it is
a fairly densely packed format (bit fields etc), the legal CTB values
cover a fair proportion of the 256 values a byte can take.  It would
break the stealthiness of it to do that.

Just checking the probablities of getting white noise that would make
it as a valid PGP message:

probability for mistaken RSA public key enc packet = 2 / 256**3 
(CTB fixed, version = 2 or 3, and algorithm byte = 1)

probability for mistaken IDEA encrypted packet = 1 / 256
(CTB fixed)

So a ~ 1/8,000,000 chance of getting asked for a non existant public
key, sound ok?

The IDEA encrypted packet is more troublesome, it'll ask for
conventional key passphrase, it'll notice if it is junk due to the
check bytes inside the IDEA encrypted packet, but only after giving
the passphrase.

Due to the IDEA packet thing, it would seem that you have to forgo the
normal PGP point and go approach, and would have to request unstealthing?

> Can stealthing the PK-encrypted session key be done transparently in
> a separate program, or does it really gain from integrating with
> PGP's handling.

I'd argue for integrating, as a core feature so that stego programs,
and remailer programs can rely on and make use of the features.

Adam


