\input texinfo.tex  @c -*-texinfo-*-
@c %** start of header
@setfilename pct.info
@settitle Python/PGP Interfaces
@syncodeindex fn cp
@syncodeindex vr cp
@c %** end of header

@titlepage
@title Python/PGP Interfaces (OUT OF DATE)
@subtitle Release 0.0.1
@subtitle Manual Edition 0.0.1
@author A.M. Kuchling
@author 762 Williams Road
@author Hemmingford, Quebec, Canada
@author E-mail: @samp{andrewk@@cst.ca}
@end titlepage

@node Top, Introduction, (dir), (dir)
@ifinfo
Certain sections require some familiarity with PGP.  
@menu
* PGP Compatibility::           Maniuplating PGP keys and messages.
@end menu

@end ifinfo

@node PGP Compatibility, , , Top
@chapter PGP Compatibility
This module is intended to allow you to manipulate files and keyrings
created by Philip Zimmermann's Pretty Good Privacy program.  If you
aren't familar with PGP, get a copy and read Philip Zimmermann's
excellent documentation.  Otherwise, this chapter will be incomprehensible to you.

Several important disclaimers: 
@itemize @bullet
@item  Currently the module cannot handle encrypted files that use PGP's
data compression.  This will require implementing a data compression
module for Python, and will not be completed any time in the near future.

@item  This Python module should be perfectly
compatible with PGP 2.6; if you find any incompatibilities, please inform me
@emph{immediately}, as they are serious bugs.

@item  PGP has been used more extensively than this code has; treat
it with care.  Bugs in software are always annoying, but this code will be
handling irreplaceable private keys.  If your private key is lost, there's
no way to recover it.  So back up your key rings before experimenting with
them, and try to verify that encrypted files you produce can be decrypted by
PGP.  This will also protect you against your own mistakes while learning
how to use the module.

@item  Any flaws in the Python PGP module are due to my error,
and should not be considered to reflect on the reputations of Philip
Zimmermann, Guido van Rossum, or the current PGP development team;
none of them had anything to do with it.

@item  The PCT's design makes it easy to change from one algorithm to
another.  This means it would be at most a few hours of work (and more
likely a few minutes) to create your own hacked PGP module that uses
triple DES or some other cipher instead of IDEA, or to add new fields
to PGP packets.  This freedom is seductive, and also dangerous; it
could lead to a twisty maze of PGP versions, all different.  That
would severely damage the usefulness of PGP, and could lead to a
collapse of PGP's usefulness as a common means of secure
communication.  Please think very carefully before creating strange
variations of PGP, and don't distribute them.

@item  As a corollary to the previous item, this module may not share
some limitations that PGP possesses; for example, RSA keys can be of
arbitrary length, while PGP is currently limited to 2048 bits.  It may
seem fun to generate an 8192-bit key, but the resulting key couldn't
be handled by any program other than this module.  Again, think before
you do something strange...
@end itemize

@section Basic design

For generality, the basic PGP module does not perform any file
handling.  Instead, all operations are performed on strings of binary
data.  So if you want to read the keys in your @code{secring.pgp}
file, you must write code to read the file, and then pass a string
containing the contents of the file to the PGP module.  This doesn't
constrain keys to being present in file-like storage, and gives you
the freedom to pass keys around in any way you like.

PGP files are broken up into packets.  A packet consists of a header,
and a given length of data.  A keyring or message is therefore a
collection of packets, arranged in some defined order.  Packets are
PGP's fundamental unit of data, but they're a bit too low-level for
convienient usage.  For example, a single key is a collection of
packets: one for the key itself, one for each user ID for the key, one
for each signature, and possibly one containing a revocation
certificate.

The Python PGP module defines a hierarchy of objects.  There are two
basic object classes: @code{Key} and @code{Data}.  There
is a lower-level @code{Packet} class that is used throughout the module.
with it. @code{Data} has several
more subclasses: XXX The Data classes have not been designed yet.

The publicly-accessible attributes and methods for the objects are
documented below.  Internal attributes and methods are accessible,
since Python doesn't yet offer data hiding, but don't use them or rely
on their existence.

The @code{__init__} functions of objects always require the same
parameter: a string of binary data that contains the data.  If the
string only contains part of a packet, an exception will be raised.
The caller can then read in more data and try again.
The exceptions that can be raised are:

@defcv Exception {PGP module} Exception
Raised on other, miscellaneous error conditions.  The associated value
is a tuple; the first element is an explanatory string, and the other
elements are associated data.
@end defcv

@defcv Exception {PGP module} PossibleEnd
This is something of an ``optional'' exception, raised if the string of
data is exactly the right length.  If you're reading keys from a file,
this may mean that the string was too short, and you were just lucky in
where it ended.  Or, you may know you have all the key data, in which
case this error can be ignored.  The associated value is the PGP object
that would have been returned; if you choose to ignore this error, just
use that object.
@end defcv

@defcv Exception {PGP module} TooShort
Raised when the string of data only contains a portion of a needed
packet of PGP data.
The associated value is an integer, giving the number of missing bytes.
You should obtain that number of bytes, and retry the instantiation.
@end defcv

@subsection Key objects
@code{Key} objects contain information about a single key, and
the User ID's associated with that key.  At the packet level, there
are different packets for the key, user IDs, and signatures.  However,
you don't have to worry about that; there are only public and private
keys.  All information about signatures and user IDs are stored as
attributes of key objects.
XXX Doesn't support revocation certificates yet!

@defivar Key ?MPI
@cindex RSA
@cindex MPI
Currently the only public-key algorithm used by PGP is RSA.  For RSA
public keys, the binary data read from the packet is stored in
@code{eMPI} and @code{nMPI}, @footnote{MPI is an acronym for
Multi-Precision Integer, the data format which PGP uses to store long
integers.}  but you'll probably never need to use them, since they're
automatically converted to long integers and kept in the @code{e}, and
@code{n} attributes.  @code{e} is the encryption exponent, and
@code{n} is the modulus.
@end defivar

@defivar Key CryptAlg
An 8-bit integer identifying the algorithm
  for which this public key is appropriate.  Currently the only
  reasonable value is 1, for the RSA algorithm.  
@end defivar

@defivar Key KeyID
A 64-bit long integer identifying the key.  This can be used as a unique
index for storing and retrieving keys, if desired.  
@end defivar

@defivar Key TimeStamp
The time that the key was generated, expressed in the standard Unix
fashion, as seconds from a reference date.
@end defivar

@defivar Key UserID
A list of tuples containing the User IDs for this key.  Each tuple is of
the form @code{(@var{IDpacket}, @var{Signaturelist})}.  
@end defivar

@defivar Key Validity
Eventually, this attribute will be used to indicate a key's lifetime,
enabling you to create keys only valid for a given period of time.
Currently this field is unused, and will always be equal to zero.
@end defivar

@defivar Key Version
The version of PGP that generated this key.  Possible values are 2 or 3.
@end defivar

Some functions are only applicable to private keys, and there are
additional attributes containing the secret key, possibly in encrypted
form.  The @code{Unlock} method must be called to transform the
encrypted data to a form suitable for use, and requires a password if
the key is encrypted.  The @code{Lock} method simply deletes the
decrypted key information, and the @code{Relock} method re-encrypts the
key, thus allowing you to change key data or generate new keys.  (XXX
@code{Relock} is implemented-but is its existence a good idea?
Carelessness could cost you a secret key, and it might be possible to
attempt a denial-of-service attack by destroying your key.)


@defivar Key ?MPI
The raw, possibly encrypted data for the private key is kept in the 
@code{dMPI}, @code{pMPI}, @code{qMPI}, and @code{uMPI} attributes.
While you could manipulate the MPI data yourself, it's probably easiest to use
the @code{Unlock} method.
@end defivar

@defivar Key CipherAlg
8-bit integer giving the secret-key algorithm used to protect the
secret key. A value of 0 means the key is stored in unencrypted form,
while 1 signals a key encrypted with IDEA.
@end defivar

@defivar Key IV
A string containing an initial block of data, used for starting the
cipher feedback for an encrypted secret key.  You'll want to set this
to a string containing random data.
@end defivar

The additional method functions allow access to the data for the
private key.

@defmethod Key Lock 
Deletes the cleartext secret key data.  Currently this simply deletes
  the @code{d}, @code{p}, @code{q}, and @code{u} attributes,
since there
  doesn't seem to be an obvious way of erasing them securely.
@end defmethod

@defmethod Key Relock password 
Recreates the secret key data by applying @var{password}, and deletes
the cleartext key data.
@end defmethod

@defmethod Key Unlock [password]
Decodes the secret key by applying @var{password}.  If the secret key
data is not encrypted, the value of @var{password} is ignored, but you
still must call the @code{Unlock} method.  After calling this method,
the key will have four additional attributes: @code{d}, @code{p},
@code{q}, and @code{u}. All of the new attributes are long integers
containing the secret key data.
@end defmethod

An example usage is given in the following example, where the user
accesses a private key protected with the password ``secret''.

@example
Python 1.1 (Nov  7 1994)
Copyright 1991-1994 Stichting Mathematisch Centrum, Amsterdam
>>> import pgp
>>> f=open('secring.pgp')
>>> binary=f.read()		# Read the entire file into a string
>>> f.close()
>>> key=pgp.Key(binary)  # Read the first private key
>>> key
<Key instance at 5ce40>
>>> key.n	# Modulus
963122082828533347002151137300146220135009078073956904069973
630338075190337890351958426139975067122956338320608624652745
4945250019523010908959292342378629L
>>> key.e	# Encryption exponent
17L
>>> key.d	# Decryption exponent not available
Traceback (innermost last):
  File "<stdin>", line 1, in ?
AttributeError: d
>>> key.CipherAlg		# Algorithm for key data
1
>>> key.Unlock('phlezofligle')	# Wrong password, so exception raised
Traceback (innermost last):		
  File "<stdin>", line 1, in ?
  File "./pgp.py", line 189, in Unlock
    raise Exception, 'Incorrect password'
pgp.Exception: Incorrect password
>>> key.Unlock('secret')	# Apply correct password
>>> key.d			# The decryption exponent
396579681164690201706768115358883737702650796853982254617047
965433325078374417342219491501744606387578757984207954329749
1347256349281128383401567984775749L
>>> ciph=pow(19721015L, key.e, key.n)	# RSA encryption
>>> ciph
103227991689207176390261587823791277903759628199625167641034
860240242223522848082032689408309240059530813895260337829589
84375L
>>> pow(ciph, key.d, key.n)	# RSA decryption
19721015L
>>> key.Lock()		# Delete sensitive data
>>> key.d		# d no longer exists
Traceback (innermost last):
  File "<stdin>", line 1, in ?
AttributeError: d
@end example

@node Concept Index, ,Extending the Toolkit, Top
@unnumbered Concept Index
@printindex cp
@contents
@bye
